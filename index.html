<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üê¢ Beau's Shell-No! üê¢</title>
    
    <!-- PWA Setup -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Turtle Favicon (Data URI) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üê¢</text></svg>">
    <link rel="apple-touch-icon" href="icon-192.png">

    <style>
        :root {
            --primary: #27ae60;
            --dark: #2c3e50;
            --accent: #f1c40f;
            --danger: #e74c3c;
            --info: #3498db;
            --panel-bg: rgba(20, 30, 40, 0.95);
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: #000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
        }
        
        /* Header - Collapsible */
        header {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            z-index: 50;
            transition: transform 0.5s ease-in-out, opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8);
        }
        header.collapsed {
            transform: translateY(-200%);
            opacity: 0;
        }
        h1 { margin: 0; font-size: 32px; color: var(--primary); font-family: 'Courier New', Courier, monospace; letter-spacing: -1px; font-weight: 900; }
        .subtitle { font-size: 14px; color: #ecf0f1; font-style: italic; margin-top: -5px; }
        
        /* Main Layout */
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* The scalable container */
        #game-container {
            position: relative;
            width: 800px;
            height: 550px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 2px solid #333;
            border-radius: 12px;
            background: #000;
            overflow: hidden;
            transform-origin: center center;
            transition: transform 0.3s ease;
        }
        
        canvas {
            background-color: #333;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* --- UI OVERLAYS --- */
        
        #stats-bar {
            position: absolute;
            top: 0; left: 0; width: 100%;
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 70%, transparent 100%);
            z-index: 10;
            pointer-events: none;
        }
        #stats-bar > * { pointer-events: auto; }

        .stats-group { display: flex; gap: 8px; }
        .stat-pill {
            background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 15px;
            font-size: 14px; font-weight: bold; display: flex; align-items: center; gap: 6px;
            border: 1px solid rgba(255,255,255,0.15); backdrop-filter: blur(2px);
        }
        .controls-group { display: flex; gap: 6px; }
        
        #tower-shop {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 8px;
            padding: 10px 10px 15px 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.7) 60%, transparent 100%);
            z-index: 10;
        }
        
        .btn {
            background: var(--dark); border: 1px solid #7f8c8d; border-radius: 8px;
            color: white; font-weight: bold; font-size: 11px; cursor: pointer;
            box-shadow: 0 2px 0 #151e26; transition: all 0.1s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 6px 8px; min-width: 55px; position: relative;
        }
        .btn:active { transform: translateY(2px); box-shadow: 0 0 0 transparent; }
        .btn:disabled { opacity: 0.5; filter: grayscale(1); transform: none; box-shadow: none; }
        .btn.selected { background: var(--primary); border-color: #2ecc71; box-shadow: 0 2px 0 #1e8449; }
        .btn-icon { font-size: 20px; margin-bottom: 2px; line-height: 1; }
        .btn small { font-size: 9px; opacity: 0.9; font-weight: normal; }
        .shop-btn { min-width: 80px; height: 60px; background: rgba(44, 62, 80, 0.9); }

        /* Upgrade Panel */
        #upgrade-panel {
            position: absolute; bottom: 80px; right: 10px;
            background: var(--panel-bg); padding: 0;
            border-radius: 12px; border: 2px solid var(--accent);
            display: flex; flex-direction: column; width: 240px;
            z-index: 20; box-shadow: 0 5px 20px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px); overflow: hidden;
            transform-origin: bottom right;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #upgrade-panel.hidden { transform: scale(0); pointer-events: none; }
        .panel-header {
            background: rgba(255,255,255,0.05); padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: space-between; align-items: center;
        }
        .panel-header h3 { margin: 0; color: var(--accent); font-size: 14px; }
        .close-btn {
            background: #e74c3c; color: white; border: none; width: 22px; height: 22px;
            border-radius: 50%; font-weight: bold; font-size: 14px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .panel-body { padding: 10px; display: flex; flex-direction: column; gap: 6px; }
        .upgrade-row {
            background: rgba(255,255,255,0.05); color: white;
            border: 1px solid #465c71; padding: 10px; border-radius: 6px;
            cursor: pointer; font-size: 12px; display: flex; justify-content: space-between;
            align-items: center; transition: background 0.1s;
        }
        .upgrade-row:active { background: rgba(255,255,255,0.1); }
        .upgrade-row span:last-child { color: var(--accent); font-weight: bold; }
        .target-btn { background: #2980b9; justify-content: center; border-color: #3498db; margin-bottom: 4px; }
        .sell-btn { margin-top: 5px; border-color: #c0392b; color: #e74c3c; background: rgba(192, 57, 43, 0.1); }

        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(26, 37, 47, 0.98);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 60; color: white; opacity: 1; transition: opacity 0.3s; padding: 20px;
        }
        .screen.hidden { opacity: 0; pointer-events: none; }
        .screen h2 { font-size: 32px; color: var(--accent); margin-bottom: 10px; font-family: 'Courier New', monospace; text-align: center; }
        .screen p { font-size: 14px; color: #bdc3c7; max-width: 600px; line-height: 1.5; margin-bottom: 25px; text-align: center; }
        
        /* Transparent Pause Screen Override */
        #screen-pause {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }

        .map-selector { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }
        .map-card {
            display: flex; flex-direction: column; width: 110px; height: 90px;
            border: 3px solid #555; cursor: pointer; position: relative;
            background: #34495e; border-radius: 12px; transition: transform 0.2s;
            overflow: hidden; align-items: center; justify-content: center;
        }
        .map-card.selected { border-color: var(--primary); box-shadow: 0 0 15px var(--primary); transform: scale(1.05); }
        .map-card .icon { font-size: 30px; margin-bottom: 5px; }
        .map-card span { font-size: 11px; font-weight: bold; padding: 2px; width: 100%; background: rgba(0,0,0,0.4); }

        .big-btn {
            padding: 12px 30px; font-size: 20px; background: var(--primary);
            border: none; color: white; border-radius: 50px; cursor: pointer;
            font-weight: bold; box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
            transition: transform 0.1s;
        }
        .big-btn:active { transform: scale(0.95); }
        
        /* Menu Buttons Row */
        .menu-row { display: flex; gap: 10px; margin-top: 15px; }
        .small-action-btn { background: transparent; border: 1px solid #7f8c8d; padding: 8px 12px; border-radius: 6px; color: #bdc3c7; font-size: 12px; cursor: pointer; }
        .small-action-btn:hover { border-color: white; color: white; }
        /* Solid background for buttons on transparent pause screen to ensure readability */
        #screen-pause .small-action-btn, #screen-pause .big-btn {
            background-color: rgba(26, 37, 47, 0.9);
            border-color: #bdc3c7;
        }
        #screen-pause .big-btn { background-color: var(--primary); border: none; }

        /* Notifications */
        #notification-area {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 300px; display: flex; flex-direction: column; align-items: center;
            gap: 5px; pointer-events: none; z-index: 100;
        }
        .toast {
            background: rgba(0,0,0,0.85); color: var(--accent); padding: 6px 14px;
            border-radius: 20px; font-weight: bold; font-size: 14px; border: 1px solid var(--accent);
            animation: floatUp 2s forwards; white-space: nowrap; box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        #boss-bar-container {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 50%; max-width: 300px; height: 24px; background: rgba(0,0,0,0.7);
            border: 2px solid #c0392b; border-radius: 15px; overflow: hidden; display: none; z-index: 90;
        }
        #boss-bar-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #c0392b, #e74c3c); transition: width 0.1s; }
        #boss-bar-label {
            position: absolute; width: 100%; text-align: center; top: 2px;
            font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px black;
            color: white; text-transform: uppercase; letter-spacing: 1px;
        }

        .version-tag {
            position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 10px;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(-5px); }
            100% { opacity: 0; transform: translateY(-15px); }
        }
    </style>
</head>
<body>

    <header id="main-header">
        <h1>üê¢ Beau's Shell-No! üê¢</h1>
        <div class="subtitle">The Slow & The Spurious</div>
    </header>

    <div id="game-wrapper">
        <!-- The Scalable Container -->
        <div id="game-container">
            
            <!-- TOP STATS BAR OVERLAY -->
            <div id="stats-bar">
                <div class="stats-group">
                    <div class="stat-pill" style="color: #e74c3c; border-color: #c0392b;">‚ù§Ô∏è <span id="lives">20</span></div>
                    <div class="stat-pill" style="color: #f1c40f; border-color: #f39c12;">üçï <span id="money">450</span></div>
                    <div class="stat-pill" style="color: #3498db; border-color: #2980b9;">üåä <span id="level">1</span></div>
                </div>
                
                <div class="controls-group">
                    <button class="btn" onclick="toggleAutoStart()" id="btn-autostart" title="Auto Start Waves">
                        <span class="btn-icon">üîÅ</span>
                    </button>
                    <button class="btn" onclick="toggleSpeed()" id="btn-speed" title="Fast Forward">
                        <span class="btn-icon">‚è©</span>
                    </button>
                    <button class="btn" onclick="buyLife()" title="Buy Life">
                        <span class="btn-icon">üíä</span>
                    </button>
                    <button class="btn" onclick="togglePause()" title="Menu">
                        <span class="btn-icon">‚è∏Ô∏è</span>
                    </button>
                </div>
            </div>

            <canvas id="gameCanvas" width="800" height="550"></canvas>
            
            <!-- Notification Area -->
            <div id="notification-area"></div>
            
            <!-- Boss Bar -->
            <div id="boss-bar-container">
                <div id="boss-bar-fill"></div>
                <div id="boss-bar-label">THE BOSS</div>
            </div>

            <!-- UPGRADE PANEL -->
            <div id="upgrade-panel" class="hidden" onclick="event.stopPropagation()">
                <div class="panel-header">
                    <h3>Upgrades</h3>
                    <button class="close-btn" onclick="closeUpgradePanel(event)">√ó</button>
                </div>
                <div class="panel-body">
                    <div class="upgrade-row target-btn" onclick="toggleTowerTargeting()">
                        üéØ Target: <span id="target-mode" style="color:white; margin-left:5px">FIRST</span>
                    </div>
                    <div id="upgrade-content"></div>
                    <div class="upgrade-row sell-btn" onclick="sellTower()">
                        <span>‚ôªÔ∏è Sell Tower</span>
                        <span>+üçï<span id="sell-val">0</span></span>
                    </div>
                </div>
            </div>

            <!-- TOWER SHOP OVERLAY -->
            <div id="tower-shop">
                <button class="btn shop-btn" id="buy-1" onclick="selectTower(1)">
                    <span class="btn-icon">üê¢</span>
                    Rifle<small>üçï50</small>
                </button>
                <button class="btn shop-btn" id="buy-2" onclick="selectTower(2)">
                    <span class="btn-icon">üî≠</span>
                    Sniper<small>üçï120</small>
                </button>
                <button class="btn shop-btn" id="buy-3" onclick="selectTower(3)">
                    <span class="btn-icon">üêå</span>
                    Alch<small>üçï200</small>
                </button>
                <button class="btn shop-btn" id="buy-4" onclick="selectTower(4)">
                    <span class="btn-icon">üí£</span>
                    Arty<small>üçï350</small>
                </button>
                <button class="btn shop-btn" id="buy-5" onclick="selectTower(5)">
                    <span class="btn-icon">ü•∑</span>
                    Ninja<small>üçï500</small>
                </button>
            </div>

            <!-- VILLAGE / MENU SCREEN -->
            <div id="screen-village" class="screen">
                <h2>The Hare Force Invasion</h2>
                <p><b>General Jackrabbit</b> has deployed his legions!<br>
                   Beware the <b style="color:#e74c3c">Tanks</b> (Immune to sharp) and <b style="color:#f1c40f">Air Support</b>!<br>
                   Deploy the Turtle Squad to defend the realm.</p>
                
                <div class="map-selector">
                    <div class="map-card selected" onclick="selectMap(0, this)">
                        <div class="icon">üèñÔ∏è</div>
                        <span>Shoreline Def</span>
                    </div>
                    <div class="map-card" onclick="selectMap(1, this)">
                        <div class="icon">üèîÔ∏è</div>
                        <span>Alpine Base</span>
                    </div>
                    <div class="map-card" onclick="selectMap(2, this)">
                        <div class="icon">üåã</div>
                        <span>Magma Core</span>
                    </div>
                </div>
                
                <button class="big-btn" onclick="startGame()">Squad Up!</button>

                <div class="menu-row">
                    <button class="small-action-btn" onclick="saveGame()">üíæ Save Progress</button>
                    <button class="small-action-btn" onclick="hardReset()">üîÑ Update / Reset</button>
                </div>
                <div class="version-tag">v1.3.1 - Tucked In Pause</div>
            </div>

            <!-- PAUSE SCREEN -->
            <div id="screen-pause" class="screen hidden">
                <h2>Tucked In</h2>
                <p>Tactical pause engaged.</p>
                <button class="big-btn" onclick="togglePause()">Come Out of Shell</button>
                <div class="menu-row">
                    <button class="small-action-btn" onclick="saveGame()">üíæ Save</button>
                    <button class="small-action-btn" onclick="returnToVillage()">üè≥Ô∏è Retreat to Menu</button>
                </div>
            </div>

            <!-- GAME OVER / WIN SCREEN -->
            <div id="screen-end" class="screen hidden">
                <h2 id="end-title">Overrun!</h2>
                <div style="font-size: 60px; margin: 10px;">üè≥Ô∏è</div>
                <p id="end-desc">The Hare Force has taken the base.</p>
                <button class="big-btn" onclick="returnToVillage()">Regroup</button>
            </div>

        </div>
    </div>

<script>
/**
 * SHELL-NO! TOWER DEFENSE v1.3.1
 * Mobile Fit Update + Pizza Economy + Strategic Corners
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Global Config ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 550;
let isPortraitMode = false; 

// --- Responsive Engine ---
function resizeGame() {
    const container = document.getElementById('game-container');
    const wrapper = document.getElementById('game-wrapper');
    
    const winWidth = window.innerWidth;
    const winHeight = window.innerHeight;
    
    isPortraitMode = winHeight > winWidth;

    if (isPortraitMode) {
        // ROTATE MODE: Scale to fit width (which is physically screen height)
        // No cap on scale
        const scale = Math.min(winWidth / GAME_HEIGHT, winHeight / GAME_WIDTH);
        
        container.style.width = `${GAME_WIDTH}px`;
        container.style.height = `${GAME_HEIGHT}px`;
        container.style.transform = `rotate(90deg) scale(${scale})`;
    } else {
        // STANDARD MODE
        const scale = Math.min(winWidth / GAME_WIDTH, winHeight / GAME_HEIGHT);
        container.style.width = `${GAME_WIDTH}px`;
        container.style.height = `${GAME_HEIGHT}px`;
        container.style.transform = `rotate(0deg) scale(${scale})`;
    }
}

window.addEventListener('resize', resizeGame);
window.addEventListener('load', resizeGame);

// Input Mapping (Corrects for Rotation/Scale)
function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;

    if (isPortraitMode) {
        const container = document.getElementById('game-container');
        const style = window.getComputedStyle(container);
        const matrix = new WebKitCSSMatrix(style.transform);
        const scale = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b); 

        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;

        const dx = clientX - cx;
        const dy = clientY - cy;

        // In rotated space: dy -> x, dx -> -y relative to center
        return {
            x: (GAME_WIDTH / 2) + (dy / scale),
            y: (GAME_HEIGHT / 2) - (dx / scale)
        };

    } else {
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }
}

// --- Configuration ---
const TOWER_TYPES = {
    1: { name: "Rifle-Shell", emoji: "üê¢", cost: 50, range: 130, damage: 25, speed: 45, dmgType: 'sharp', desc: "Sharp. Fails vs Tanks." },
    2: { name: "Sniper-Shell", emoji: "üî≠", cost: 120, range: 250, damage: 90, speed: 90, dmgType: 'sharp', desc: "High Range/Dmg." },
    3: { name: "Alchemist", emoji: "üêå", cost: 200, range: 150, damage: 15, speed: 60, dmgType: 'chem', desc: "Corrosive. Melts Tanks." },
    4: { name: "Shell-tillery", emoji: "üí£", cost: 350, range: 200, damage: 50, speed: 120, dmgType: 'explosive', desc: "Splash. Breaks Tanks." },
    5: { name: "Shinobi", emoji: "ü•∑", cost: 500, range: 140, damage: 40, speed: 20, dmgType: 'sharp', desc: "Fast Crit. Fails vs Tanks." }
};

// UPDATED MAP PATHS TO CLEAR BOTTOM UI (Max Y ~420)
const MAPS = [
    { 
        name: "Shoreline Defense", 
        bgColor: '#3498db', 
        type: 'beach',
        pathColor: '#f1c40f', 
        path: [{x:0,y:100}, {x:200,y:100}, {x:200,y:400}, {x:500,y:400}, {x:500,y:150}, {x:700,y:150}, {x:700,y:400}, {x:850,y:400}] 
    },
    { 
        name: "Alpine Base", 
        bgColor: '#81d4fa', 
        type: 'snow',
        pathColor: '#bdc3c7', 
        path: [{x:0,y:275}, {x:200,y:275}, {x:200,y:100}, {x:400,y:100}, {x:400,y:400}, {x:600,y:400}, {x:600,y:275}, {x:850,y:275}] 
    },
    { 
        name: "Magma Core", 
        bgColor: '#2c3e50', 
        type: 'lava',
        pathColor: '#5a3030', 
        path: [{x:0,y:50}, {x:100,y:50}, {x:100,y:420}, {x:300,y:420}, {x:300,y:100}, {x:600,y:100}, {x:600,y:400}, {x:850,y:400}] 
    }
];

// --- State Variables ---
let gameState = 'MENU';
let currentMapIndex = 0;
let money = 450;
let lives = 20;
let level = 1;
let frames = 0;
let gameSpeed = 1;
let autoStart = false;
let animationId;

let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];
let floatingTexts = [];
let activeBoss = null;

let waveActive = false;
let enemiesToSpawn = 0;
let spawnTimer = 0;
let currentEnemyTypes = [];

let selectedTowerType = null;
let selectedTowerInstance = null;
let mouseX = 0;
let mouseY = 0;
let repairCost = 150;

// --- Engine Core ---

function init() {
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').catch(err => console.log('SW fail', err));
        });
    }
    
    if (localStorage.getItem('shellNo_save')) {
        // save found
    }

    switchScreen('screen-village');
    loop();
    resizeGame();
}

function saveGame() {
    const data = {
        money,
        lives,
        level,
        mapIndex: currentMapIndex
    };
    localStorage.setItem('shellNo_save', JSON.stringify(data));
    showToast("Game Saved!");
}

function loadGame() {
    const data = JSON.parse(localStorage.getItem('shellNo_save'));
    if (data) {
        money = data.money;
        lives = data.lives;
        level = data.level;
        currentMapIndex = data.mapIndex || 0;
        return true;
    }
    return false;
}

function hardReset() {
    if(confirm("Update game version and reset all progress?")) {
        localStorage.removeItem('shellNo_save');
        if('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
                window.location.reload(true);
            });
        } else {
            window.location.reload(true);
        }
    }
}

function selectMap(index, el) {
    currentMapIndex = index;
    document.querySelectorAll('.map-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
}

function startGame() {
    gameState = 'PLAYING';
    document.getElementById('main-header').classList.add('collapsed');
    switchScreen(null);
    resetGame();
    startWave();
    updateUI();
}

function resetGame() {
    money = 450;
    lives = 20;
    level = 1;
    repairCost = 150;
    gameSpeed = 1;
    autoStart = false;
    towers = [];
    enemies = [];
    projectiles = [];
    particles = [];
    floatingTexts = [];
    activeBoss = null;
    clearToasts();
    document.getElementById('boss-bar-container').style.display = 'none';
    document.getElementById('btn-speed').classList.remove('selected');
    document.getElementById('btn-autostart').classList.remove('selected');
}

function startWave() {
    waveActive = true;
    const waveConfig = getWaveConfig(level);
    enemiesToSpawn = waveConfig.count;
    currentEnemyTypes = waveConfig.types;
    spawnTimer = 0;
    
    if (currentEnemyTypes.includes('general') || currentEnemyTypes.includes('tank')) {
        showToast(`‚ö†Ô∏è HEAVY UNITS APPROACHING! ‚ö†Ô∏è`);
    } else {
        showToast(`Wave ${level}: Incoming!`);
    }
}

function getWaveConfig(lvl) {
    const loop = Math.floor((lvl - 1) / 10);
    const stage = (lvl - 1) % 10 + 1;

    let types = ['recruit'];
    if (stage > 2) types.push('pilot');
    if (stage >= 6) types.push('tank'); 
    
    if (stage === 10) return { count: 1 + loop, interval: 200, types: ['general'] };
    if (stage === 5) return { count: 2 + loop, interval: 150, types: ['tank'] };
    
    if (stage > 7) types.push('tank');

    const count = 5 + (stage * 1.5) + (loop * 5);
    const interval = Math.max(20, 80 - (stage * 3));
    
    return { count: Math.floor(count), interval, types };
}

function update() {
    if (gameState !== 'PLAYING') return;

    const steps = gameSpeed === 1 ? 1 : 2;
    
    for(let s=0; s<steps; s++) {
        frames++;

        if (enemiesToSpawn > 0) {
            if (spawnTimer <= 0) {
                const type = currentEnemyTypes[Math.floor(Math.random() * currentEnemyTypes.length)];
                const newEnemy = new Enemy(type, level, MAPS[currentMapIndex].path);
                enemies.push(newEnemy);
                
                if (type === 'general') {
                    activeBoss = newEnemy;
                    document.getElementById('boss-bar-container').style.display = 'block';
                    document.getElementById('boss-bar-label').innerText = "GENERAL JACKRABBIT";
                }
                
                enemiesToSpawn--;
                const waveData = getWaveConfig(level);
                spawnTimer = waveData.interval;
            } else {
                spawnTimer--;
            }
        } else if (enemies.length === 0 && waveActive) {
            waveActive = false;
            level++;
            money += 100 + (level * 10);
            showToast("Wave Clear!");
            
            if (autoStart) {
                setTimeout(startWave, 1000 / gameSpeed);
            }
        }

        towers.forEach(t => t.update());
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            enemies[i].update();
            if (enemies[i].dead) {
                addFloatText(`+üçï${enemies[i].reward}`, enemies[i].x, enemies[i].y, '#f1c40f');
                if (enemies[i] === activeBoss) {
                    activeBoss = null;
                    document.getElementById('boss-bar-container').style.display = 'none';
                }
                enemies.splice(i, 1);
            }
            else if (enemies[i].reachedEnd) {
                lives -= (enemies[i].type === 'general' ? 99 : 1);
                addFloatText("OUCH!", enemies[i].x, enemies[i].y, '#c0392b');
                if (enemies[i] === activeBoss) {
                    activeBoss = null;
                    document.getElementById('boss-bar-container').style.display = 'none';
                }
                enemies.splice(i, 1);
                if (lives <= 0) gameOver();
            }
        }

        for (let i = projectiles.length - 1; i >= 0; i--) {
            projectiles[i].update();
            if (!projectiles[i].active) projectiles.splice(i, 1);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
    }
    
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].update();
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }
    
    updateUI();
}

function draw() {
    const map = MAPS[currentMapIndex];
    drawMapBackground(map);

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.lineWidth = 52;
    if (map.type === 'lava') {
        ctx.strokeStyle = '#c0392b';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#e74c3c';
    } else {
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.shadowBlur = 0;
    }
    ctx.beginPath();
    ctx.moveTo(map.path[0].x, map.path[0].y);
    for(let i=1; i<map.path.length; i++) ctx.lineTo(map.path[i].x, map.path[i].y);
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.lineWidth = 40;
    ctx.strokeStyle = map.pathColor;
    ctx.beginPath();
    ctx.moveTo(map.path[0].x, map.path[0].y);
    for(let i=1; i<map.path.length; i++) ctx.lineTo(map.path[i].x, map.path[i].y);
    ctx.stroke();

    const end = map.path[map.path.length-1];
    const bounce = Math.sin(frames * 0.05) * 5;
    ctx.font = '50px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üè≥Ô∏è', end.x, end.y - 10 + bounce);
    ctx.font = '30px Arial';
    ctx.fillText('üè∞', end.x, end.y + 10 + bounce);

    towers.forEach(t => t.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    projectiles.forEach(p => p.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    floatingTexts.forEach(f => f.draw(ctx));

    if (selectedTowerType && gameState === 'PLAYING') {
        const tType = TOWER_TYPES[selectedTowerType];
        const valid = isValidPlacement(mouseX, mouseY);
        
        ctx.save();
        ctx.translate(mouseX, mouseY);
        
        ctx.beginPath();
        ctx.fillStyle = valid ? 'rgba(200, 200, 200, 0.3)' : 'rgba(231, 76, 60, 0.4)';
        ctx.arc(0, 0, tType.range, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = valid ? '#fff' : '#c0392b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.globalAlpha = 0.8;
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(tType.emoji, 0, 0);
        
        ctx.restore();
    } else if (selectedTowerInstance) {
        const t = selectedTowerInstance;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; 
        ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.7)'; 
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 3;
        ctx.arc(t.x, t.y, 25, 0, Math.PI*2);
        ctx.stroke();
    }
}

function drawMapBackground(map) {
    if (map.type === 'beach') {
        const sand = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sand.addColorStop(0, '#f1c40f');
        sand.addColorStop(1, '#d35400');
        ctx.fillStyle = sand;
        ctx.fillRect(0,0,canvas.width, canvas.height);
        
        ctx.fillStyle = '#3498db';
        ctx.beginPath(); ctx.arc(100, 100, 80, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(700, 400, 100, 0, Math.PI*2); ctx.fill();
        
        drawEmoji(50, 50, 'üå¥', 40);
        drawEmoji(750, 50, 'üå¥', 40);
        drawEmoji(100, 500, 'üå¥', 40);

    } else if (map.type === 'snow') {
        const snow = ctx.createLinearGradient(0, 0, 0, canvas.height);
        snow.addColorStop(0, '#ecf0f1');
        snow.addColorStop(1, '#bdc3c7');
        ctx.fillStyle = snow;
        ctx.fillRect(0,0,canvas.width, canvas.height);
        
        ctx.fillStyle = '#95a5a6';
        ctx.beginPath(); ctx.moveTo(0, 550); ctx.lineTo(200, 100); ctx.lineTo(400, 550); ctx.fill();
        ctx.beginPath(); ctx.moveTo(400, 550); ctx.lineTo(600, 150); ctx.lineTo(800, 550); ctx.fill();
        
        drawEmoji(100, 300, 'üå≤', 30);
        drawEmoji(700, 300, 'üå≤', 30);
        drawEmoji(400, 50, 'üå≤', 30);

    } else if (map.type === 'lava') {
        const rock = ctx.createRadialGradient(400, 275, 10, 400, 275, 500);
        rock.addColorStop(0, '#2c3e50');
        rock.addColorStop(1, '#000000');
        ctx.fillStyle = rock;
        ctx.fillRect(0,0,canvas.width, canvas.height);
        
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3;
        for(let i=0; i<10; i++) {
            ctx.beginPath();
            ctx.moveTo(Math.random()*800, Math.random()*550);
            ctx.lineTo(Math.random()*800, Math.random()*550);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        drawEmoji(50, 500, 'üî•', 30);
        drawEmoji(750, 50, 'üî•', 30);
    }
}

function drawEmoji(x, y, char, size) {
    ctx.font = `${size}px Arial`;
    ctx.fillText(char, x, y);
}

function loop() {
    update();
    draw();
    animationId = requestAnimationFrame(loop);
}

// --- Classes ---

class Tower {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        const data = TOWER_TYPES[type];
        
        this.emoji = data.emoji;
        this.range = data.range;
        this.damage = data.damage;
        this.maxCooldown = data.speed;
        this.dmgType = data.dmgType;
        
        this.cooldown = 0;
        this.rotation = 0;
        this.targetAngle = 0;
        this.targeting = 'first'; 

        this.lvlDmg = 0;
        this.lvlSpd = 0;
        this.spentValue = data.cost;
    }

    update() {
        if (this.cooldown > 0) this.cooldown--;
        
        let candidates = enemies.filter(e => {
            return Math.hypot(e.x - this.x, e.y - this.y) <= this.range;
        });

        if (candidates.length === 0) return;

        if (this.targeting === 'first') candidates.sort((a, b) => b.pathIndex - a.pathIndex);
        else if (this.targeting === 'last') candidates.sort((a, b) => a.pathIndex - b.pathIndex);
        else if (this.targeting === 'strong') candidates.sort((a, b) => b.hp - a.hp);
        else if (this.targeting === 'close') {
            candidates.sort((a, b) => {
                return Math.hypot(a.x - this.x, a.y - this.y) - Math.hypot(b.x - this.x, b.y - this.y);
            });
        }

        let target = candidates[0];

        if (target) {
            this.targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
            
            if (this.cooldown <= 0) {
                this.shoot(target);
                this.cooldown = this.maxCooldown;
            }
        }
    }

    shoot(target) {
        let pType = 'normal';
        if (this.dmgType === 'chem') pType = 'goop';
        if (this.dmgType === 'explosive') pType = 'bomb';
        if (this.type === 5) pType = 'star';
        
        projectiles.push(new Projectile(this.x, this.y, target, this.damage, pType, this.dmgType));
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 15, 15, 8, 0, 0, Math.PI*2); ctx.fill();

        if (Math.abs(this.targetAngle) > Math.PI/2) ctx.scale(-1, 1);

        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        
        if (this.lvlDmg > 0) {
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath(); ctx.arc(15, -15, 5, 0, Math.PI*2); ctx.fill();
        }
        if (this.lvlSpd > 0) {
            ctx.fillStyle = '#3498db';
            ctx.beginPath(); ctx.arc(-15, -15, 5, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Enemy {
    constructor(type, level, path) {
        this.type = type;
        this.path = path;
        this.pathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.dead = false;
        this.reachedEnd = false;
        this.isTank = false; 
        this.slowTimer = 0;
        this.wobble = Math.random() * 10;
        this.facing = 1;

        const multi = 1 + (level * 0.2);

        if (type === 'recruit') {
            this.emoji = 'üêá'; this.speed = 2.5; this.hp = 20 * multi; this.reward = 8;
        } else if (type === 'pilot') {
            this.emoji = 'üõ©Ô∏è'; this.speed = 3.5; this.hp = 15 * multi; this.reward = 12;
        } else if (type === 'tank') {
            this.emoji = 'üöú'; this.speed = 0.8; this.hp = 150 * multi; this.reward = 30; this.isTank = true;
        } else if (type === 'general') {
            this.emoji = 'üê∞'; this.speed = 0.6; this.hp = 3000 * multi; this.reward = 500;
        }

        this.maxHp = this.hp;
        this.baseSpeed = this.speed;
    }

    update() {
        let currentSpeed = this.baseSpeed;
        if (this.slowTimer > 0) {
            currentSpeed *= 0.5;
            this.slowTimer--;
            if (Math.random() < 0.1) particles.push(new Particle(this.x, this.y, '#3498db', 10));
        }

        const target = this.path[this.pathIndex + 1];
        if (!target) {
            this.reachedEnd = true;
            return;
        }

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);

        // CORNER SLOW LOGIC
        // If getting close to the next waypoint (but not the last base point), slow down
        // We exclude the last point so they don't slow down entering the base.
        if (dist < 40 && this.pathIndex < this.path.length - 2) {
            currentSpeed *= 0.6; // 40% speed reduction for cornering
        }

        if (dx < -0.1) this.facing = -1;
        else if (dx > 0.1) this.facing = 1;

        if (dist < currentSpeed) {
            this.x = target.x;
            this.y = target.y;
            this.pathIndex++;
        } else {
            this.x += (dx/dist) * currentSpeed;
            this.y += (dy/dist) * currentSpeed;
        }
        this.wobble += 0.2;
    }

    takeDamage(amt, type) {
        if (this.isTank && type === 'sharp') {
            if (Math.random() < 0.2) addFloatText("TINK!", this.x, this.y - 10, '#95a5a6'); 
            return;
        }

        this.hp -= amt;
        if (type === 'goop' || type === 'chem') this.slowTimer = 90; 
        
        if (this.hp <= 0) {
            this.dead = true;
            money += this.reward;
            const color = this.type === 'tank' ? '#555' : '#ecf0f1';
            for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, color));
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const scale = this.type === 'general' ? 2 : 1.2;
        ctx.scale(this.facing * scale, scale);
        const hop = Math.abs(Math.sin(this.wobble)) * 5;
        ctx.translate(0, -hop);
        
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Shadow
        ctx.save();
        ctx.scale(1, 0.3);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.arc(0, 40, 10, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        if (this.slowTimer > 0) {
            ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
            ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fill();
        }

        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, target, damage, type, dmgType) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.type = type;       
        this.dmgType = dmgType; 
        this.active = true;
        this.speed = 10;
        this.isCrit = false;

        if (type === 'star' && Math.random() < 0.3) {
            this.damage *= 2;
            this.isCrit = true;
        }
    }

    update() {
        if (!this.target || this.target.dead) {
            this.active = false;
            return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist < this.speed) {
            this.hit();
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    hit() {
        this.active = false;
        if (this.type === 'bomb') {
            enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < 80) e.takeDamage(this.damage, this.dmgType);
            });
            particles.push(new Particle(this.x, this.y, '#e74c3c', 20));
        } else {
            this.target.takeDamage(this.damage, this.dmgType);
            if (this.isCrit) addFloatText("CRIT!", this.x, this.y - 20, '#e74c3c');
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = this.type === 'goop' ? '#2ecc71' : 'white';
        
        if (this.type === 'bomb') {
            ctx.font = '16px Arial'; ctx.fillText('üí£', -8, 4);
        } else if (this.type === 'star') {
            ctx.rotate(frames * 0.5); 
            ctx.font = '16px Arial'; ctx.fillText('‚≠ê', -8, 4);
        } else {
            ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, life=20) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random()-0.5)*5;
        this.vy = (Math.random()-0.5)*5;
        this.life = life;
        this.maxLife = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class FloatingText {
    constructor(text, x, y, color) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.color = color;
        this.life = 40;
        this.dy = -1;
    }
    update() {
        this.y += this.dy;
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 40);
        ctx.fillStyle = this.color;
        ctx.font = 'bold 16px Arial';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

// --- Inputs & Logic ---

// Updated to use the smart coordinate mapper
function handleInput(e) {
    if (gameState !== 'PLAYING') return;
    
    // Prevent default touch actions (like scrolling) inside game
    // e.preventDefault(); // Optional: careful with blocking UI interaction

    const pos = getMousePos(e);
    mouseX = pos.x;
    mouseY = pos.y;

    if (e.type === 'mousedown' || e.type === 'touchstart') {
        if (selectedTowerType) {
            if (money >= TOWER_TYPES[selectedTowerType].cost && isValidPlacement(mouseX, mouseY)) {
                money -= TOWER_TYPES[selectedTowerType].cost;
                towers.push(new Tower(mouseX, mouseY, selectedTowerType));
                for(let i=0; i<8; i++) particles.push(new Particle(mouseX, mouseY, '#f1c40f'));
                selectedTowerType = null; 
                updateUI();
            }
        } else {
            const clicked = towers.find(t => Math.hypot(t.x - mouseX, t.y - mouseY) < 30);
            if (clicked) openUpgradePanel(clicked);
            else closeUpgradePanel();
        }
    }
}

// Add listeners to Canvas only
canvas.addEventListener('mousemove', e => {
    const pos = getMousePos(e);
    mouseX = pos.x;
    mouseY = pos.y;
});
canvas.addEventListener('mousedown', handleInput);
canvas.addEventListener('touchstart', handleInput, {passive: false});

canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    selectedTowerType = null;
    updateUI();
});

function isValidPlacement(x, y) {
    if (x < 30 || x > canvas.width - 30 || y < 30 || y > canvas.height - 30) return false;
    const path = MAPS[currentMapIndex].path;
    for(let i=0; i<path.length-1; i++) {
        if (pointLineDist(x, y, path[i].x, path[i].y, path[i+1].x, path[i+1].y) < 50) return false;
    }
    for(let t of towers) {
        if (Math.hypot(t.x - x, t.y - y) < 45) return false;
    }
    return true;
}

// --- UI Logic ---

function showToast(msg) {
    const container = document.getElementById('notification-area');
    const div = document.createElement('div');
    div.className = 'toast';
    div.innerText = msg;
    container.appendChild(div);
    setTimeout(() => { if(div.parentElement) div.remove(); }, 2000);
}

function clearToasts() {
    document.getElementById('notification-area').innerHTML = '';
}

function addFloatText(txt, x, y, color) {
    floatingTexts.push(new FloatingText(txt, x, y, color));
}

function toggleSpeed() {
    gameSpeed = gameSpeed === 1 ? 2 : 1;
    const btn = document.getElementById('btn-speed');
    if (gameSpeed === 2) btn.classList.add('selected');
    else btn.classList.remove('selected');
}

function toggleAutoStart() {
    autoStart = !autoStart;
    const btn = document.getElementById('btn-autostart');
    if (autoStart) {
        btn.classList.add('selected');
        if (!waveActive && enemies.length === 0) startWave();
    } else {
        btn.classList.remove('selected');
    }
}

function togglePause() {
    if (gameState === 'PLAYING') {
        gameState = 'PAUSED';
        switchScreen('screen-pause');
    } else if (gameState === 'PAUSED') {
        gameState = 'PLAYING';
        switchScreen(null);
    }
}

function selectTower(id) {
    if (gameState !== 'PLAYING') return;
    selectedTowerType = (selectedTowerType === id) ? null : id;
    closeUpgradePanel();
    updateUI();
}

function updateUI() {
    document.getElementById('lives').innerText = lives;
    document.getElementById('money').innerText = Math.floor(money);
    document.getElementById('level').innerText = level;
    
    // Tower Buttons
    for(let i=1; i<=5; i++) {
        const btn = document.getElementById(`buy-${i}`);
        if(btn) {
            btn.disabled = money < TOWER_TYPES[i].cost;
            if (selectedTowerType === i) btn.classList.add('selected');
            else btn.classList.remove('selected');
        }
    }
    
    if (selectedTowerInstance) renderUpgrades();

    if (activeBoss) {
        const pct = Math.max(0, (activeBoss.hp / activeBoss.maxHp) * 100);
        document.getElementById('boss-bar-fill').style.width = pct + '%';
    }
}

// --- Upgrades ---

function openUpgradePanel(tower) {
    selectedTowerInstance = tower;
    document.getElementById('upgrade-panel').classList.remove('hidden');
    renderUpgrades();
}

function closeUpgradePanel(e) {
    if (e) e.stopPropagation(); 
    selectedTowerInstance = null;
    document.getElementById('upgrade-panel').classList.add('hidden');
}

function toggleTowerTargeting() {
    if (!selectedTowerInstance) return;
    const modes = ['first', 'last', 'strong', 'close'];
    let idx = modes.indexOf(selectedTowerInstance.targeting);
    idx = (idx + 1) % modes.length;
    selectedTowerInstance.targeting = modes[idx];
    renderUpgrades();
}

function renderUpgrades() {
    if (!selectedTowerInstance) return;
    const t = selectedTowerInstance;
    const div = document.getElementById('upgrade-content');
    
    document.getElementById('target-mode').innerText = t.targeting.toUpperCase();
    
    const dCost = Math.floor(TOWER_TYPES[t.type].cost * 0.6 * (t.lvlDmg + 1));
    const sCost = Math.floor(TOWER_TYPES[t.type].cost * 0.6 * (t.lvlSpd + 1));
    
    document.getElementById('sell-val').innerText = Math.floor(t.spentValue * 0.75);

    div.innerHTML = `
        <div class="upgrade-row" onclick="buyUpgrade('dmg')">
            <span>üí™ Power (L${t.lvlDmg})</span>
            <span>üçï${dCost}</span>
        </div>
        <div class="upgrade-row" onclick="buyUpgrade('spd')">
            <span>‚ö° Haste (L${t.lvlSpd})</span>
            <span>üçï${sCost}</span>
        </div>
    `;
}

function buyUpgrade(upgradeType) {
    if (!selectedTowerInstance) return;
    const t = selectedTowerInstance;
    let cost = 0;
    
    if (upgradeType === 'dmg') cost = Math.floor(TOWER_TYPES[t.type].cost * 0.6 * (t.lvlDmg + 1));
    else cost = Math.floor(TOWER_TYPES[t.type].cost * 0.6 * (t.lvlSpd + 1));

    if (money >= cost) {
        money -= cost;
        t.spentValue += cost;
        if (upgradeType === 'dmg') { t.lvlDmg++; t.damage *= 1.3; }
        else { t.lvlSpd++; t.maxCooldown *= 0.8; }
        addFloatText("UPGRADE!", t.x, t.y - 30, '#2ecc71');
        updateUI();
    } else {
        showToast("Need Pizza!");
    }
}

function sellTower() {
    if (selectedTowerInstance) {
        money += Math.floor(selectedTowerInstance.spentValue * 0.75);
        const idx = towers.indexOf(selectedTowerInstance);
        if (idx > -1) towers.splice(idx, 1);
        closeUpgradePanel();
        updateUI();
    }
}

function buyLife() {
    if (money >= repairCost && lives < 20) {
        money -= repairCost;
        lives = Math.min(20, lives + 5);
        repairCost = Math.floor(repairCost * 1.5);
        showToast("Shell Patched!");
        updateUI();
    } else {
        showToast("Need Pizza!");
    }
}

// --- Helpers ---

function switchScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    if (id) document.getElementById(id).classList.remove('hidden');
}

function returnToVillage() {
    gameState = 'MENU';
    document.getElementById('main-header').classList.remove('collapsed');
    switchScreen('screen-village');
    closeUpgradePanel();
}

function gameOver() {
    gameState = 'GAME_OVER';
    switchScreen('screen-end');
}

function pointLineDist(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = -1;
    if (len_sq != 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

// Start
init();

</script>
</body>
</html>
